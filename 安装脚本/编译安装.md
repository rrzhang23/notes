## autossh
```
if [ ! -f "autossh-1.4g-1-x86_64.pkg.tar.xz" ];then
    echo "正在下载 autossh..."
    wget -O autossh-1.4g-1-x86_64.pkg.tar.xz http://ftp5.gwdg.de/pub/linux/archlinux/community/os/x86_64//autossh-1.4g-1-x86_64.pkg.tar.xz
fi
if [ ! -f "autossh-1.4g-1-x86_64.pkg.tar" ];then
    xz -dk autossh-1.4g-1-x86_64.pkg.tar.xz
fi
# mkdir autossh-1.4g-1-x86_64
tar -xf autossh-1.4g-1-x86_64.pkg.tar
mv usr/ autossh-1.4g-1-x86_64/ 
mv autossh-1.4g-1-x86_64/ ~/.local/
```

## boost
boost 一般是不用安装的，直接解压 `boost_1_69_0.zip` 就可以使用（把 boost_1_69_0 放到自己环境目录就行）。  
也有部分库需要安装，编译后生成 `include`、`lib`两个文件夹。可以直接放到上面的 `boost_1_69_0` 文件夹里。
### 直接解压
```
if [ ! -f "boost_1_69_0.zip" ];then
	echo "正在下载 boost_1_69_0.zip..."
	wget -O boost_1_69_0.zip https://dl.bintray.com/boostorg/release/1.69.0/source/boost_1_69_0.zip
fi
unzip boost_1_69_0.zip
mv boost_1_69_0 $HOME/.local/
```

### 编译安装
```
// 我的环境目录
cd ~/.local
wget https://dl.bintray.com/boostorg/release/1.69.0/source/boost_1_69_0.zip
unzip boost_1_69_0.zip > /dev/null
cd boost_1_69_0
./bootstrap.sh --with-libraries=all --with-toolset=gcc
nohup time ./b2 install --prefix=/home/zhangrongrong/.local/boost_1_69_0 -j32 &
```

## make
```
if [ ! -f "make-4.2.1.tar.gz" ];then
    echo "正在下载 make..."
    wget -O make-4.2.1.tar.gz wget http://ftp.gnu.org/gnu/make/make-4.2.1.tar.gz
fi
rm -rf make-4.2.1
tar -xf make-4.2.1.tar.gz
cd make-4.2.1
make clean
./configure --prefix=$HOME/.local/make-4.2.1
make -j32
make install
cd ../
rm -rf make-4.2.1
```

### .bashrc
```
# make
export MAKE_ROOT=$HOME/.local/make-4.2.1
export      PATH=$MAKE_ROOT/bin:$PATH
```

## cmake
```
if [ ! -f "cmake-3.14.5-Linux-x86_64.tar.gz" ];then
    echo "downloading autossh..."
    wget -O cmake-3.14.5-Linux-x86_64.tar.gz https://cmake.org/files/v3.14/cmake-3.14.5-Linux-x86_64.tar.gz
fi
tar -xf cmake-3.14.5-Linux-x86_64.tar.gz
mv cmake-3.14.5-Linux-x86_64/ cmake-3.14.5/
mv cmake-3.14.5/ ~/.local/
```

### .bashrc
```
# cmake
export CMAKE_HOME=$HOME/.local/cmake-3.14.5
export       PATH=$CMAKE_HOME/bin:$PATH
```

## protobuf
```
unset CPLUS_INCLUDE_PATH C_INCLUDE_PATH LIBRARY_PATH
git clone git@github.com:protocolbuffers/protobuf.git
cd protobuf
git checkout 4.0.x
git submodule update --init --recursive
git reset --hard
git clean -d -fx
```
### 分两种安装方式
configure 安装  

-fPIC支持：`./configure CXXFLAGS=-fPIC CFLAGS=-fPIC`
```
./autogen.sh
./configure --prefix=$HOME/.local/protobuf-4.0.x CXXFLAGS=-fPIC CFLAGS=-fPIC && make -j32 && make install
ln -s /home/zhangrongrong/.local/protobuf-4.0.x/lib/ /home/zhangrongrong/.local/protobuf-4.0.x/lib64
# 这里 lib64 和 lib64/ 有区别
```


cmake 安装

只能编出 .a 和 .so 中一种（即使同时指定`-DBUILD_SHARED_LIBS=ON -DBUILD_STATIC_LIBS=ON`），库安装在 lib64/ 下，有 protobuf-config.cmake。  
-fPIC支持：编辑 CMakeList.txt, 加入`set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fPIC") set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fPIC")`

```
# cmake，注意 -fPIC支持
cd cmake
mkdir build && cd build

# 先安装动态库
cmake -DCMAKE_BUILD_TYPE=Release \
-DBUILD_SHARED_LIBS=ON           \
-DCMAKE_INSTALL_PREFIX=/home/zhangrongrong/.local/protobuf-4.0.x         \
-G "Unix Makefiles" ..
make -j32 && make install

# 再安装静态库
rm -rf ../build/*
cmake -DCMAKE_BUILD_TYPE=Release \
-DCMAKE_INSTALL_PREFIX=/home/zhangrongrong/.local/protobuf-4.0.x         \
-G "Unix Makefiles" ..
make -j32 && make install

cd ../..
rm -rf cmake/build

ln -s /home/zhangrongrong/.local/protobuf-4.0.x/lib64/ /home/zhangrongrong/.local/protobuf-4.0.x/lib
```
### 配置 .bashrc
```
# protobuf
export      Protobuf_root=$HOME/.local/protobuf-4.0.x
export               PATH=$Protobuf_root/bin:$PATH
export    LD_LIBRARY_PATH=$Protobuf_root/lib64:$Protobuf_root/lib:$LD_LIBRARY_PATH
export       LIBRARY_PATH=$LD_LIBRARY_PATH:$LIBRARY_PATH
export        LD_RUN_PATH=$LD_LIBRARY_PATH:$LD_RUN_PATH
export     C_INCLUDE_PATH=$Protobuf_root/include:$C_INCLUDE_PATH
export CPLUS_INCLUDE_PATH=$C_INCLUDE_PATH:$CPLUS_INCLUDE_PATH
```

## gflag
一般安装是有问题的，需要打开共享库开关，另外要指定 namespace
```
git clone git@github.com:gflags/gflags.git
cd gflags
git reset --hard
git clean -d -fx
mkdir build
cd build
rm -rf ../build/*
cmake -DCMAKE_INSTALL_PREFIX=/home/zhangrongrong/.local/gflags -DBUILD_SHARED_LIBS=ON -DGFLAGS_NAMESPACE=google -G "Unix Makefiles" .. && make -j32 && make install
```
```
# gflags
export        gflags_root=$HOME/.local/gflags
export               PATH=$gflags_root/bin:$PATH
export    LD_LIBRARY_PATH=$gflags_root/lib64:$gflags_root/lib:$LD_LIBRARY_PATH
export       LIBRARY_PATH=$LD_LIBRARY_PATH:$LIBRARY_PATH
export        LD_RUN_PATH=$LD_LIBRARY_PATH:$LD_RUN_PATH
export     C_INCLUDE_PATH=$gflags_root/include:$C_INCLUDE_PATH
export CPLUS_INCLUDE_PATH=$C_INCLUDE_PATH:$CPLUS_INCLUDE_PATH
```

## googletest
```
git clone git@github.com:google/googletest.git
cd googletest
mkdir build && cd build
cmake -DCMAKE_INSTALL_PREFIX=/home/zhangrongrong/.local/googletest .. && make -j32 && make install
```

## snappy
谷歌压缩库，依赖 gflag、googletest

通过编辑 `~/.bashrc` 设置环境变量好像并不管用，snappy 依然找不到上述依赖包。

修改 CMakeList.txt，指定 find_package 查找的目录：
```
find_package(GTest QUIET PATHS /home/zhangrongrong/.local/gooletest NO_DEFAULT_PATH)
if(GTEST_FOUND)
  set(HAVE_GTEST 1)
endif(GTEST_FOUND)

find_package(Gflags QUIET PATHS /home/zhangrongrong/.local/gflag NO_DEFAULT_PATH)
if(GFLAGS_FOUND)
  set(HAVE_GFLAGS 1)
endif(GFLAGS_FOUND)
```

```
git clone git@github.com:google/snappy.git
cd snappy
# 修改 CMakeList.txt
mkdir build && cd build
cmake -DCMAKE_INSTALL_PREFIX=/home/zhangrongrong/.local/snappy -DSNAPPY_BUILD_TESTS=0 -DCMAKE_BUILD_TYPE=Release .. && make -j32 && make install
```
> 可以不安装

## leveldb
```
git clone git@github.com:google/leveldb.git
cd leveldb
git submodule update --init --recursive
git reset --hard
git clean -d -fx
mkdir build
cd build
cmake -DBUILD_SHARED_LIBS=ON -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=/home/zhangrongrong/.local/leveldb .. && make -j32 && make install
```

使用 leveldb 时，只需要连接 leveldb、snappy、pthread 的库就行。

### 遇到问题
1. 
leveldb 的 cmake 默认以 `-fno-rtti` 方式编译库文件。  
在用自定义比较器 Comparator 时，会遇到 `~Comparator` 未定义引用问题。

解决方法：可以将 leveldb CmakeLists.txt 里的 `-fno-rtti` 行注释掉，再编译库文件。
2.
默认只能编译出静态库，但是加入`-DBUILD_SHARED_LIBS=ON` 想编出动态库时，出现问题。  
解决方法：
在 CMakeLists.txt 里找到以下行:
```
  add_subdirectory("third_party/googletest")
```
改成：
```
  set(BUILD_SHARED_LIBS OFF)
  add_subdirectory("third_party/googletest")
  set(BUILD_SHARED_LIBS ON)
```


## openssl
官网源码 
```
https://www.openssl.org/source/old
```

```
wget https://www.openssl.org/source/old/1.0.2/openssl-1.0.2k.tar.gz
tar -xf openssl-1.0.2k.tar.gz
cd openssl-1.0.2k
./config --prefix=/home/zhangrongrong/.local/openssl-1.0.2k shared
make -j32 && make install
```
```
# openssl
export       OPENSSL_ROOT=$HOME/.local/openssl-1.0.2k
export               PATH=$OPENSSL_ROOT/bin:$PATH
export    LD_LIBRARY_PATH=$OPENSSL_ROOT/lib64:$OPENSSL_ROOT/lib:$LD_LIBRARY_PATH
export       LIBRARY_PATH=$LD_LIBRARY_PATH:$LIBRARY_PATH
export        LD_RUN_PATH=$LD_LIBRARY_PATH:$LD_RUN_PATH
export     C_INCLUDE_PATH=$OPENSSL_ROOT/include:$C_INCLUDE_PATH
export CPLUS_INCLUDE_PATH=$C_INCLUDE_PATH:$CPLUS_INCLUDE_PATH
```

## trojan
```
cmake -DCMAKE_INSTALL_PREFIX=/home/zhangrongrong/.local/trojan \
-DCMAKE_INCLUDE_PATH="/home/zhangrongrong/.local/boost_1_69_0/include;/home/zhangrongrong/.local/openssl-1.1.0l/include" \
-DCMAKE_LIBRARY_PATH="/home/zhangrongrong/.local/boost_1_69_0/lib;/home/zhangrongrong/.local/openssl-1.1.0l/lib" \
-DSYSTEMD_SERVICE=OFF \
..
```